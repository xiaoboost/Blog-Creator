{"path":"/post/closures-bind","name":"closures-bind","title":"Function.prototype.bind","category":"软件设计","date":["2016","06","08"],"tag":["JavaScript","规范"],"layout":"post","toc":[{"tocTitle":"实验","bolt":"BE5AE9EE9AA8C"},{"tocTitle":"函数调用","bolt":"BE587BDE695B0E8B083E794A8"},{"tocTitle":"bind方法","bolt":"BbindE696B9E6B395"},{"tocTitle":"绑定函数的调用","bolt":"BE7BB91E5AE9AE587BDE695B0E79A84E8B083E794A8"},{"tocTitle":"总结","bolt":"BE680BBE7BB93"}],"excerpt":["这个东西是我偶然想到的，之前在写矩阵求解器的时候，给每个元素封装了很多接口，其中一个是某种特殊的运算，这个运算根据元素不同内部的参数也不同，最开始直接用的bind将参数绑定的，那速度简直太惨了，后来经人提醒换成了闭包，效果才比较能接受。于是我就有了探究bind方法的想法。"],"next":{"path":"/post/up-going","title":"Up & Going"},"prev":{"path":"/post/requirejs-source","title":"requireJS源码浅析"},"content":"<p class=\"warning\"><span>本文中的所有规范均是ES6版本的。</span></p><p><span>JavaScript中的函数也是值，当然也可以到处传递，经常会有这样的需求，那就是根据不同情况生成不同的函数，函数的主体结构是一样的，只是内部有些参数不同。实现这样的需求并不难，有两种比较典型的做法，一个是使用闭包，在闭包中保存参数最后返回函数本身，还有一个就是用函数直接将参数bind，这样在函数内就能直接使用<code>this</code>了。</span><span>闭包自不必说了，除了作用域不会被垃圾回收之外，它的调用和普通函数一样，本文主要就是讲述<code>bind</code>之后的函数相比普通函数的区别。</span></p><h1 id=\"BE5AE9EE9AA8C\">实验</h1><p><span>先做个简单的实验：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li></ul><ul class=\"code\"><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">method</span>) </span>{</li><li>    <span class=\"hljs-keyword\">var</span> obj = { <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-number\">1</span> };</li><li></li><li>    <span class=\"hljs-keyword\">if</span>(method === <span class=\"hljs-number\">1</span>) {</li><li>        <span class=\"hljs-keyword\">return</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{</li><li>            obj.name = i;</li><li>        });</li><li>    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(method === <span class=\"hljs-number\">2</span>) {</li><li>        <span class=\"hljs-keyword\">return</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>) </span>{</li><li>            <span class=\"hljs-keyword\">this</span>.name = i;</li><li>        }.bind(obj));</li><li>    }</li><li>}</li><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span> (<span class=\"hljs-params\">func</span>) </span>{</li><li>    <span class=\"hljs-keyword\">let</span> i;</li><li>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10000000</span>; i++)  {</li><li>        func(i);</li><li>    }</li><li>}</li><li><span class=\"hljs-built_in\">console</span>.time(<span class=\"hljs-string\">'Closure'</span>);</li><li>test(func(<span class=\"hljs-number\">1</span>));</li><li><span class=\"hljs-built_in\">console</span>.timeEnd(<span class=\"hljs-string\">'Closure'</span>);</li><li><span class=\"hljs-built_in\">console</span>.time(<span class=\"hljs-string\">'Bind'</span>);</li><li>test(func(<span class=\"hljs-number\">2</span>));</li><li><span class=\"hljs-built_in\">console</span>.timeEnd(<span class=\"hljs-string\">'Bind'</span>);</li><li></li><li><span class=\"hljs-comment\">//Closure: 6.058ms</span></li><li><span class=\"hljs-comment\">//Bind: 86.811ms</span></li></ul></code></pre><p><span><code>func</code>函数中有一个公共的对象obj，当<code>method === 1</code>的时候返回一个直接操作obj的函数，这是闭包方法；当<code>method === 2</code>的时候返回一个操作this指针的函数，而这个函数将绑定<code>obj</code>为它的<code>this</code>。</span><span>结果差异非常显著：由于电脑性能的不同，在不同电脑上运行的结果可能会有差异，但是这个近14倍的差距确是毋容置疑的。</span></p><p><span>到底是什么造成了这样的差距？</span></p><h1 id=\"BE587BDE695B0E8B083E794A8\">函数调用</h1><p><span>先来说说函数调用，函数调用实际上就是调用函数对象内置的<code>[[call]]</code>方法，普通函数对象的这个方法在规范中是这样的：</span></p><blockquote><p><span>[[Call]] ( thisArgument, argumentsList)</span></p><ol><li><p><span>Assert: F is an ECMAScript function object.</span></p></li><li><p><span>If F’s [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.</span></p></li><li><p><span>Let callerContext be the running execution context.</span></p></li><li><p><span>Let calleeContext be PrepareForOrdinaryCall(F, undefined).</span></p></li><li><p><span>Assert: calleeContext is now the running execution context.</span></p></li><li><p><span>Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).</span></p></li><li><p><span>Let result be OrdinaryCallEvaluateBody(F, argumentsList).</span></p></li><li><p><span>Remove calleeContext from the execution context stack and restore callerContext as the running execution context.</span></p></li><li><p><span>If result.[[type]] is return, return NormalCompletion(result.[[value]]).</span></p></li><li><p><span>ReturnIfAbrupt(result).</span></p></li><li><p><span>Return NormalCompletion(undefined).</span></p></li></ol></blockquote><p><span>虽然很长，其实很简单的：</span></p><ol><li><p><span>令<code>F</code>为函数对象</span></p></li><li><p><span>令<code>callerContext</code>为函数运行的上下文</span></p></li><li><p><span>绑定当前函数的<code>this</code></span></p></li><li><p><span>运行当前函数，并令<code>result</code>为函数运行结果</span></p></li><li><p><span>若<code>result</code>有值，那么返回它，否则返回<code>undefined</code></span></p></li></ol><p><span>我们都知道，<code>bind</code>方法将会改变函数运行的上下文，也就是改变函数运行时的<code>this</code>，上文中我们也看到普通函数调用也是要绑定<code>this</code>的，那么我们先看看它是如何在运行时绑定<code>this</code>的。</span></p><p><span>在上述步骤中，绑定<code>this</code>的是这个函数<code>OrdinaryCallBindThis</code>，我们继续看规范：</span></p><blockquote><p><span>OrdinaryCallBindThis ( F, calleeContext, thisArgument )</span></p><ol><li><p><span>Let thisMode be the value of F’s [[thisMode]] internal slot.</span></p></li><li><p><span>If thisMode is lexical, return NormalCompletion(undefined).</span></p></li><li><p><span>Let calleeRealm be the value of F’s [[Realm]] internal slot.</span></p></li><li><p><span>Let localEnv be the LexicalEnvironment of calleeContext.</span></p></li><li><p><span>If thisMode is strict, let thisValue be thisArgument.</span></p></li><li><p><span>Else</span></p><ol><li><p><span>if thisArgument is null or undefined, then</span></p><ol><li><p><span>Let thisValue be calleeRealm.[[globalThis]].</span></p></li></ol></li><li><p><span>Else</span></p><ol><li><p><span>Let thisValue be ToObject(thisArgument).</span></p></li><li><p><span>Assert: thisValue is not an abrupt completion.</span></p></li><li><p><span>NOTE ToObject produces wrapper objects using calleeRealm.</span></p></li></ol></li></ol></li><li><p><span>Let envRec be localEnv’s EnvironmentRecord.</span></p></li><li><p><span>Assert: The next step never returns an abrupt completion because envRec.[[thisBindingStatus]] is not \"uninitialized\".</span></p></li><li><p><span>Return envRec.BindThisValue(thisValue).</span></p></li></ol></blockquote><p><span>这里就比较复杂了，变量也比较多，咱们挨个来。</span><span><code>thisMode</code>，这个变量是来自函数<code>F</code>的内部参数<code>[[ThisMode]]</code>，这个值代表着函数内<code>this</code>的取值方式，它一共有三个取值：</span></p><ol><li><p><span><code>lexical</code>，此时<code>this</code>的值将会是函数所在封闭作用域的那个<code>this</code>（箭头函数的<code>词法this</code>）</span></p></li><li><p><span><code>strict</code>，此时<code>this</code>会等于函数调用的变量<code>thisArgument</code></span></p></li><li><p><span><code>global</code>，如果此时<code>thisArgument</code>未定义，那么此时<code>this</code>会指向全局变量</span></p></li></ol><p><span><code>calleeRealm</code>，这个变量是函数<code>F</code>的内部参数<code>[[Realm]]</code>，它是在函数运行之前的准备数据。但是，它并不是环境参数，代表函数词法环境的是另一个内建参数<code>[[Environment]]</code>。</span><span><code>calleeContext</code>，这个输入的变量代表着执行的上下文环境。</span><span><code>localEnv</code>，这个变量是<code>calleeContext</code>之中的词法环境。</span><span><code>envRec</code>，而这个变量是<code>localEnv</code>之中的环境记录，它包含了当前运行环境中的所有声明和对象环境。</span><span>在最后，将<code>thisValue</code>绑定到<code>envRec</code>之中，函数运行的准备就完成了。</span></p><p><span>可以看到，在普通的函数调用中，<code>this</code>的绑定是由运行时的上下文来决定的。函数调用就是调用函数对象自身的<code>[[call]]</code>方法。</span></p><h1 id=\"BbindE696B9E6B395\"><code>bind</code>方法</h1><p><span>那么，我们现在再来看看<code>bind</code>方法都做了什么：</span></p><blockquote><p><span>Function.prototype.bind ( thisArg, ...args)</span></p><ol><li><p><span>Let Target be the this value.</span></p></li><li><p><span>If IsCallable(Target) is false, throw a TypeError exception.</span></p></li><li><p><span>Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.</span></p></li><li><p><span>Let F be ? BoundFunctionCreate(Target, thisArg, args).</span></p></li><li><p><span>Let targetHasLength be ? HasOwnProperty(Target, \"length\").</span></p></li><li><p><span>If targetHasLength is true, then</span></p><ol><li><p><span>Let targetLen be ? Get(Target, \"length\").</span></p></li><li><p><span>If Type(targetLen) is not Number, let L be 0.</span></p></li><li><p><span>Else,</span></p><ol><li><p><span>Let targetLen be ToInteger(targetLen).</span></p></li><li><p><span>Let L be the larger of 0 and the result of targetLen minus the number of elements of args.</span></p></li></ol></li></ol></li><li><p><span>Else, let L be 0.</span></p></li><li><p><span>Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor {[[Value]]: L, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).</span></p></li><li><p><span>Let targetName be ? Get(Target, \"name\").</span></p></li><li><p><span>If Type(targetName) is not String, let targetName be the 11. empty string.</span></p></li><li><p><span>Perform SetFunctionName(F, targetName, \"bound\").</span></p></li><li><p><span>Return F.</span></p></li></ol></blockquote><p><span>可以看到，在这里它创建并返回了个新的函数<code>F</code>，这个函数的诸多属性和原本的函数都是一样的，唯一有一点，就是构造这个新函数的方法是<code>BoundFunctionCreate</code>。</span><span>我们来看看这个特殊的方法是什么：</span></p><blockquote><p><span>BoundFunctionCreate (targetFunction, boundThis, boundArgs)</span></p><ol><li><p><span>Assert: Type(targetFunction) is Object.</span></p></li><li><p><span>Let proto be ? targetFunction.[[GetPrototypeOf]]().</span></p></li><li><p><span>Let obj be a newly created object.</span></p></li><li><p><span>Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.</span></p></li><li><p><span>Set the [[Call]] internal method of obj as described in 9.4.1.1.</span></p></li><li><p><span>If targetFunction has a [[Construct]] internal method, then</span></p><ol><li><p><span>Set the [[Construct]] internal method of obj as described in 9.4.1.2.</span></p></li></ol></li><li><p><span>Set obj.[[Prototype]] to proto.</span></p></li><li><p><span>Set obj.[[Extensible]] to true.</span></p></li><li><p><span>Set obj.[[BoundTargetFunction]] to targetFunction.</span></p></li><li><p><span>Set obj.[[BoundThis]] to boundThis.</span></p></li><li><p><span>Set obj.[[BoundArguments]] to boundArgs.</span></p></li><li><p><span>Return obj.</span></p></li></ol></blockquote><p><span>可以看到，这个构造函数的实例是继承了原版函数的，不过修改了<code>[[call]]</code>属性，而且还新增加了<code>[[BoundTargetFunction]]</code>、<code>[[BoundThis]]</code>以及<code>[[BoundArguments]]</code>这三个属性。</span><span>这三个新增的属性，从名字就能看出它们是绑定的目标函数，绑定的<code>this</code>，以及绑定的输入参数。</span><span>这个新的实例在规范中的名字是叫<code>bound function</code>。好直白……绑定函数……</span></p><h1 id=\"BE7BB91E5AE9AE587BDE695B0E79A84E8B083E794A8\">绑定函数的调用</h1><p><span>既然最终返回的<code>F</code>函数还修改了<code>[[call]]</code>，那么这个新的<code>[[call]]</code>是什么样的呢：</span></p><blockquote><p><span>[[Call]] ( thisArgument, argumentsList)</span></p><ol><li><p><span>Let target be F.[[BoundTargetFunction]].</span></p></li><li><p><span>Let boundThis be F.[[BoundThis]].</span></p></li><li><p><span>Let boundArgs be F.[[BoundArguments]].</span></p></li><li><p><span>Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values as the list argumentsList in the same order.</span></p></li><li><p><span>Return ? Call(target, boundThis, args).</span></p></li></ol></blockquote><p><span>就是把内部参数取出之后调用了<code>Call</code>。这个<code>Call</code>是JavaScript内部的抽象函数，并没有对外暴露的，它的过程其实很简单。</span></p><blockquote><p><span>Call (F, V [ , argumentsList ])</span></p><ol><li><p><span>If argumentsList was not passed, let argumentsList be a new empty List.</span></p></li><li><p><span>If IsCallable(F) is false, throw a TypeError exception.</span></p></li><li><p><span>Return ? F.[[Call]](V, argumentsList).</span></p></li></ol></blockquote><p><span>可以看到它只是做了格式检查，然后就直接调用函数<code>F</code>了。这个函数<code>F</code>就是原来我们绑定的原函数，这里就又回到普通函数调用那里了。</span></p><h1 id=\"BE680BBE7BB93\">总结</h1><p><span>到此为止我们可以看出，我们可以做总结了：</span></p><ol><li><p><span>函数调用，实际上都是调用其内部的<code>[[call]]</code>方法。</span></p></li><li><p><span><code>bind</code>方法会生成一个继承自<code>Function</code>的实例，这个实例外带新增了三个参数（绑定时的参数），并修改了自身的<code>[[call]]</code>。</span></p></li><li><p><span><code>bind</code>方法生成的函数在调用的时候依旧会调用内部的<code>[[call]]</code>方法，但是这个方法只是取出参数之后又去调用了另外一个<code>Call</code>函数，最后才会调用真正的函数。</span></p></li><li><p><span>也就是说<code>bind</code>方法生成的函数最后在调用的时候，比普通的函数调用多了2个步骤。那么它比闭包的函数速度慢也确实是理所当然的。</span></p></li></ol>"}