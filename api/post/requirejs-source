{"path":"/post/requirejs-source","name":"requirejs-source","title":"requireJS源码浅析","category":"软件设计","date":["2016","03","17"],"tag":["JavaScript","requireJS","异步"],"layout":"post","toc":[{"tocTitle":"初始化","bolt":"初始化","child":[{"tocTitle":"主程序入口","bolt":"主程序入口","parent":"初始化"},{"tocTitle":"初次运行入口函数","bolt":"初次运行入口函数","parent":"初始化"},{"tocTitle":"记录用户主程序路径","bolt":"记录用户主程序路径","parent":"初始化"},{"tocTitle":"第二次运行入口函数","bolt":"第二次运行入口函数","parent":"初始化"},{"tocTitle":"加载用户主程序","bolt":"加载用户主程序","parent":"初始化"},{"tocTitle":"加载检查","bolt":"加载检查","parent":"初始化"}]},{"tocTitle":"require.config","bolt":"require.config"},{"tocTitle":"require","bolt":"require","child":[{"tocTitle":"Module类","bolt":"Module类","parent":"require"},{"tocTitle":"具体过程","bolt":"具体过程","parent":"require"}]},{"tocTitle":"define","bolt":"define"},{"tocTitle":"依赖的依赖","bolt":"依赖的依赖"},{"tocTitle":"总结","bolt":"总结"}],"excerpt":["初次使用requireJs的时候有很多不甚明了的地方，于是乎就有了看看源码的心思，再加上它的代码加上注释也不过2000+行，而且注释又非常详尽，看起来貌似不怎么困难……我看之前是这么想的……结果发现其实很难……但是半途而废感觉又不太好，还是硬着头皮看了几遍，很多细节问题吃不透，只能理解个大概，本文是我自己的笔记，如果有错误还请指正。另外，本文看着很长，其实有大半都是源码的复制黏贴，水得很……"],"next":{"path":"/post/closures-bind","title":"Function.prototype.bind"},"prev":{"path":"/post/function-dec-exp-ano","title":"函数声明与函数表达式"},"content":"<h1 id=\"初始化\">初始化</h1><h2 id=\"主程序入口\">主程序入口</h2><p><span>阅读源码首先当然是寻找程序入口，<code>requireJS</code>模块的入口便是引用它本身的<code>&lt;script&gt;</code>标签。</span></p><pre class=\"html\"><code><ul class=\"gutter\"><li>1</li></ul><ul class=\"code\"><li><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"require.js\"</span> <span class=\"hljs-attr\">data-main</span>=<span class=\"hljs-string\">\"lib/main.js\"</span>&gt;</span><span class=\"undefined\"></span></li></ul></code></pre><p><span>Js文件引入之后，模块本身就会被加载，先来看看模块初始化的时候做了什么。</span><span>requireJS模块的整体结构是一个立即执行函数和3个全局变量：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li></ul><ul class=\"code\"><li><span class=\"hljs-keyword\">var</span> requirejs, <span class=\"hljs-built_in\">require</span>, define;</li><li>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">global</span>) </span>{……}(<span class=\"hljs-keyword\">this</span>));</li></ul></code></pre><p><span>立即执行函数的输入参数是<code>this</code>，全局运行的时候this肯定是指向<code>window</code>的，那么这个立即执行函数的<code>global</code>就是<code>window</code>。</span><span>由入口进入之后定义了一大堆变量方法，然后来到了这里，做了第一件事：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//Create default context.</span></li><li>req({});</li></ul></code></pre><h2 id=\"初次运行入口函数\">初次运行入口函数</h2><p><span><code>req({})</code>就是初次运行的入口函数，它的函数原型是：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li></ul><ul class=\"code\"><li>req = requirejs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">deps, callback, errback, optional</span>) </span>{｝</li></ul></code></pre><p><span>初次运行输入参数是一个空对象，里面的代码只有两句有效（这里就不贴源码了，源码在后面）：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul><ul class=\"code\"><li><span class=\"hljs-keyword\">if</span> (!context) {</li><li>  context = contexts[contextName] = req.s.newContext(contextName);</li><li>}</li><li><span class=\"hljs-keyword\">if</span> (config) {</li><li>  context.configure(config);</li><li>}</li></ul></code></pre><p><span>初次运行context是空值，将会运行<code>newContext()</code>方法，这个方法很特殊，它只会在初始化的时候运行一次，之后便不会再运行了，但它的代码洋洋洒洒占据了全部代码的三分之二。</span><span>这个方法会不仅是属性参数的初始化，还会创建并在之后持续维护一个闭包，这个闭包保存了几个临时变量。此方法运行没有什么特别的代码，就是一堆工具函数和变量的定义，完成初始化之后，立刻就用空的配置调用了<code>context.configure</code>方法初始化了<code>shim</code>和<code>path</code>等参数。这里面的函数方法之后碰到了再详细说，现在挨个说了也记不住，先找找<code>data-main</code>的处理函数。</span></p><h2 id=\"记录用户主程序路径\">记录用户主程序路径</h2><p><span>再往后就能看到处理<code>data-main</code>相关的逻辑了，代码是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//Look for a data-main script attribute, </span></li><li><span class=\"hljs-comment\">// which could also adjust the baseUrl.</span></li><li><span class=\"hljs-keyword\">if</span> (isBrowser &amp;&amp; !cfg.skipDataMain) {</li><li>  <span class=\"hljs-comment\">//Figure out baseUrl. Get it from the script tag with require.js in it.</span></li><li>  eachReverse(scripts(), <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">script</span>) </span>{</li><li>    <span class=\"hljs-comment\">//Set the 'head' where we can append children by</span></li><li>    <span class=\"hljs-comment\">//using the script's parent.</span></li><li>    <span class=\"hljs-keyword\">if</span> (!head) {</li><li>      head = script.parentNode;</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//Look for a data-main attribute to set main script for the page</span></li><li>    <span class=\"hljs-comment\">//to load. If it is there, the path to data main becomes the</span></li><li>    <span class=\"hljs-comment\">//baseUrl, if it is not already set.</span></li><li>    dataMain = script.getAttribute(<span class=\"hljs-string\">'data-main'</span>);</li><li>    <span class=\"hljs-keyword\">if</span> (dataMain) {</li><li>      <span class=\"hljs-comment\">//Preserve dataMain in case it is a path (i.e. contains '?')</span></li><li>      mainScript = dataMain;</li><li></li><li>      <span class=\"hljs-comment\">//Set final baseUrl if there is not already an explicit one,</span></li><li>      <span class=\"hljs-comment\">//but only do so if the data-main value is not a loader plugin</span></li><li>      <span class=\"hljs-comment\">//module ID.</span></li><li>      <span class=\"hljs-keyword\">if</span> (!cfg.baseUrl &amp;&amp; mainScript.indexOf(<span class=\"hljs-string\">'!'</span>) === <span class=\"hljs-number\">-1</span>) {</li><li>        <span class=\"hljs-comment\">//Pull off the directory of data-main for use as the</span></li><li>        <span class=\"hljs-comment\">//baseUrl.</span></li><li>        src = mainScript.split(<span class=\"hljs-string\">'/'</span>);</li><li>        mainScript = src.pop();</li><li>        subPath = src.length ? src.join(<span class=\"hljs-string\">'/'</span>)  + <span class=\"hljs-string\">'/'</span> : <span class=\"hljs-string\">'./'</span>;</li><li></li><li>        cfg.baseUrl = subPath;</li><li>      }</li><li></li><li>      <span class=\"hljs-comment\">//Strip off any trailing .js since mainScript is now</span></li><li>      <span class=\"hljs-comment\">//like a module name.</span></li><li>      mainScript = mainScript.replace(jsSuffixRegExp, <span class=\"hljs-string\">''</span>);</li><li></li><li>      <span class=\"hljs-comment\">//If mainScript is still a path, fall back to dataMain</span></li><li>      <span class=\"hljs-keyword\">if</span> (req.jsExtRegExp.test(mainScript)) {</li><li>        mainScript = dataMain;</li><li>      }</li><li></li><li>      <span class=\"hljs-comment\">//Put the data-main script in the files to load.</span></li><li>      cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];</li><li></li><li>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;</li><li>    }</li><li>  });</li><li>}</li></ul></code></pre><p><span>因为<code>requireJS</code>不止用于浏览器，所以在入口处有一个判断，如果当前是浏览器那么<code>isBrowser = true</code>，后面那个暂且不管它。进入之后有一个名为<code>eachReverse</code>的方法，它将会逆序遍历传入的第一个参数，而第一个参数是：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li></ul><ul class=\"code\"><li>scripts() =&gt; <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">'script'</span>);</li></ul></code></pre><p><span>这里返回了页面中的所有script标签，然后逆序遍历之。这一段代码的含义就是寻找拥有<code>data-main</code>属性的标签，并记录主程序入口文件的路径并记录。</span><span>就以我们章节开头的那个标签为例，这里将会保存为——</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li></ul><ul class=\"code\"><li>cfg = {</li><li>  baseUrl = <span class=\"hljs-string\">\"lib/\"</span>,</li><li>  deps = [<span class=\"hljs-string\">\"main\"</span>]</li><li>}</li></ul></code></pre><p><span><code>cfg.baseUr1</code>将会保存基础路径，<code>cfg.deps</code>将会保存入口文件名。同时<code>baseUrl</code>这个属性会被记录到<code>require.config</code>中，也就是说如果后续不更改基础路径属性的话，就会默认<code>data-main</code>的目录了。</span></p><h2 id=\"第二次运行入口函数\">第二次运行入口函数</h2><p><span>好了，程序入口已经找到，进入下一个步骤。之后将会再一次运行入口函数，上一次运行入口函数只是初始化，这一次将<code>cfg</code>作为参数传入了。</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">//Set up with config info.</span></li><li>req(cfg);</li></ul></code></pre><p><span>入口函数<code>req</code>的代码如下：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li></ul><ul class=\"code\"><li>req = requirejs = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">deps, callback, errback, optional</span>) </span>{</li><li></li><li>  <span class=\"hljs-comment\">//Find the right context, use default</span></li><li>  <span class=\"hljs-keyword\">var</span> context, config,</li><li>    contextName = defContextName;</li><li></li><li>  <span class=\"hljs-comment\">// Determine if have config object in the call.</span></li><li>  <span class=\"hljs-keyword\">if</span> (!isArray(deps) &amp;&amp; <span class=\"hljs-keyword\">typeof</span> deps !== <span class=\"hljs-string\">'string'</span>) {</li><li>    <span class=\"hljs-comment\">// deps is a config object</span></li><li>    config = deps;</li><li>    <span class=\"hljs-keyword\">if</span> (isArray(callback)) {</li><li>      <span class=\"hljs-comment\">// Adjust args if there are dependencies</span></li><li>      deps = callback;</li><li>      callback = errback;</li><li>      errback = optional;</li><li>    } <span class=\"hljs-keyword\">else</span> {</li><li>      deps = [];</li><li>    }</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (config &amp;&amp; config.context) {</li><li>    contextName = config.context;</li><li>  }</li><li></li><li>  context = getOwn(contexts, contextName);</li><li>  <span class=\"hljs-keyword\">if</span> (!context) {</li><li>    context = contexts[contextName] = req.s.newContext(contextName);</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (config) {</li><li>    context.configure(config);</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">return</span> context.require(deps, callback, errback);</li><li>};</li></ul></code></pre><p><span>调用<code>context.configure(config)</code>保存了输入的<code>deps</code>参数之后，再调用<code>require</code>。</span><span>之后几个函数来回回调，实际上最后调用的是个名叫<code>localRequire</code>的方法，这个方法的源码是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li>51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li><li>68</li><li>69</li></ul><ul class=\"code\"><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">localRequire</span>(<span class=\"hljs-params\">deps, callback, errback</span>) </span>{</li><li>  <span class=\"hljs-keyword\">var</span> id, map, requireMod;</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (options.enableBuildCallback &amp;&amp; callback &amp;&amp; isFunction(callback)) {</li><li>    callback.__requireJsBuild = <span class=\"hljs-literal\">true</span>;</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> deps === <span class=\"hljs-string\">'string'</span>) {</li><li>    <span class=\"hljs-keyword\">if</span> (isFunction(callback)) {</li><li>      <span class=\"hljs-comment\">//Invalid call</span></li><li>      <span class=\"hljs-keyword\">return</span> onError(</li><li>        makeError(</li><li>          <span class=\"hljs-string\">'requireargs'</span>, </li><li>          <span class=\"hljs-string\">'Invalid require call'</span></li><li>        ),</li><li>      errback);</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//If require|exports|module are requested, get the</span></li><li>    <span class=\"hljs-comment\">//value for them from the special handlers. Caveat:</span></li><li>    <span class=\"hljs-comment\">//this only works while module is being defined.</span></li><li>    <span class=\"hljs-keyword\">if</span> (relMap &amp;&amp; hasProp(handlers, deps)) {</li><li>      <span class=\"hljs-keyword\">return</span> handlers[deps](registry[relMap.id]);</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//Synchronous access to one module. If require.get is</span></li><li>    <span class=\"hljs-comment\">//available (as in the Node adapter), prefer that.</span></li><li>    <span class=\"hljs-keyword\">if</span> (req.get) {</li><li>      <span class=\"hljs-keyword\">return</span> req.get(context, deps, relMap, localRequire);</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//Normalize module name, if it contains . or ..</span></li><li>    map = makeModuleMap(deps, relMap, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>);</li><li>    id = map.id;</li><li></li><li>    <span class=\"hljs-keyword\">if</span> (!hasProp(defined, id)) {</li><li>      <span class=\"hljs-keyword\">return</span> onError(makeError(<span class=\"hljs-string\">'notloaded'</span>, <span class=\"hljs-string\">'Module name \"'</span> +</li><li>        id +</li><li>        <span class=\"hljs-string\">'\" has not been loaded yet for context: '</span> +</li><li>        contextName +</li><li>        (relMap ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">'. Use require([])'</span>)));</li><li>    }</li><li>    <span class=\"hljs-keyword\">return</span> defined[id];</li><li>  }</li><li></li><li>  <span class=\"hljs-comment\">//Grab defines waiting in the global queue.</span></li><li>  intakeDefines();</li><li></li><li>  <span class=\"hljs-comment\">//Mark all the dependencies as needing to be loaded.</span></li><li>  context.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>    <span class=\"hljs-comment\">//Some defines could have been added since the</span></li><li>    <span class=\"hljs-comment\">//require call, collect them.</span></li><li>    intakeDefines();</li><li></li><li>    requireMod = getModule(makeModuleMap(<span class=\"hljs-literal\">null</span>, relMap));</li><li></li><li>    <span class=\"hljs-comment\">//Store if map config should be applied to this require</span></li><li>    <span class=\"hljs-comment\">//call for dependencies.</span></li><li>    requireMod.skipMap = options.skipMap;</li><li></li><li>    requireMod.init(deps, callback, errback, {</li><li>      <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span></li><li>    });</li><li></li><li>    checkLoaded();</li><li>  });</li><li></li><li>  <span class=\"hljs-keyword\">return</span> localRequire;</li><li>}</li></ul></code></pre><p><span>当<code>deps</code>是字符串的情况下，这个<code>if</code>里面的东西那先不管，直接看下面。<code>intakeDefines()</code>，这个会将两个全局队列清空，这两个全局队列保存的是当前已经引用的全部依赖模块，在调用运行函数的时候会把它们取出，现在里面什么都没有，这里是没什么用的。</span><span>接下来就是重头戏了，<code>nextTick()</code>方法实际上是一个延迟函数，源码在这里：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">/**</li><li> * Execute something after the current tick</li><li> * of the event loop. Override for other envs</li><li> * that have a better solution than setTimeout.</li><li> * @param  {Function} fn function to execute later.</li><li> */</span></li><li>req.nextTick = <span class=\"hljs-keyword\">typeof</span> setTimeout !== <span class=\"hljs-string\">'undefined'</span> ? <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fn</span>) </span>{</li><li>  setTimeout(fn, <span class=\"hljs-number\">4</span>);</li><li>} : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fn</span>) </span>{ fn(); };</li></ul></code></pre><p><span>可以看出默认异步延迟了4毫秒，从时间顺序上来说这个异步函数的内容是最后才会运行的。</span><span>它的内容很简单，那就是找出输入的<code>Module</code>，在网页上加载这个<code>module</code>的<code>script</code>标签，值得注意的是加载这个标签是异步的。</span></p><h2 id=\"加载用户主程序\">加载用户主程序</h2><p><span>延迟函数中的程序很简单，只有几句话，首先<code>intakeDefines()</code>，取出载入的模块。然后紧接着就是<code>getModule(makeModuleMap(null, relMap))</code>。</span><span>先说<code>makeModuleMap</code>，它会按照一定的规则生成一个独一无二的对象，规则的具体细节就不说了。然后是<code>getModule()</code>，之所以先定义再直接取出是因为要把生成的对象加入到<code>registry</code>这个全局变量中，<code>getModule</code>的源码很短：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li></ul><ul class=\"code\"><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getModule</span>(<span class=\"hljs-params\">depMap</span>) </span>{</li><li>  <span class=\"hljs-keyword\">var</span> id = depMap.id,</li><li>    mod = getOwn(registry, id);</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (!mod) {</li><li>    mod = registry[id] = <span class=\"hljs-keyword\">new</span> context.Module(depMap);</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">return</span> mod;</li><li>}</li></ul></code></pre><p><span><strong>这里能看出预先加载过的模块，之后就不用重新加载了。</strong></span><span>接下来配置取出的<code>Moudle</code>，<code>deps</code>存着入口程序的地址。<code>init()</code>方法很明显是初始化：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li></ul><ul class=\"code\"><li>Module.prototype.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">depMaps, factory, errback, options</span>) </span>{</li><li>  options = options || {};</li><li>  <span class=\"hljs-comment\">//Do not do more inits if already done. Can happen if there</span></li><li>  <span class=\"hljs-comment\">//are multiple define calls for the same module. That is not</span></li><li>  <span class=\"hljs-comment\">//a normal, common case, but it is also not unexpected.</span></li><li>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.inited) {</li><li>    <span class=\"hljs-keyword\">return</span>;</li><li>  }</li><li>  <span class=\"hljs-keyword\">this</span>.factory = factory;</li><li>  <span class=\"hljs-keyword\">if</span> (errback) {</li><li>    <span class=\"hljs-comment\">//Register for errors on this module.</span></li><li>    <span class=\"hljs-keyword\">this</span>.on(<span class=\"hljs-string\">'error'</span>, errback);</li><li>  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.events.error) {</li><li>    <span class=\"hljs-comment\">//If no errback already, but there are error listeners</span></li><li>    <span class=\"hljs-comment\">//on this module, set up an errback to pass to the deps.</span></li><li>    errback = bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{</li><li>      <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-string\">'error'</span>, err);</li><li>    });</li><li>  }</li><li>  <span class=\"hljs-comment\">//Do a copy of the dependency array, so that</span></li><li>  <span class=\"hljs-comment\">//source inputs are not modified. For example</span></li><li>  <span class=\"hljs-comment\">//\"shim\" deps are passed in here directly, and</span></li><li>  <span class=\"hljs-comment\">//doing a direct modification of the depMaps array</span></li><li>  <span class=\"hljs-comment\">//would affect that config.</span></li><li>  <span class=\"hljs-keyword\">this</span>.depMaps = depMaps &amp;&amp; depMaps.slice(<span class=\"hljs-number\">0</span>);</li><li>  <span class=\"hljs-keyword\">this</span>.errback = errback;</li><li>  <span class=\"hljs-comment\">//Indicate this module has be initialized</span></li><li>  <span class=\"hljs-keyword\">this</span>.inited = <span class=\"hljs-literal\">true</span>;</li><li>  <span class=\"hljs-keyword\">this</span>.ignore = options.ignore;</li><li>  <span class=\"hljs-comment\">//Could have option to init this module in enabled mode,</span></li><li>  <span class=\"hljs-comment\">//or could have been previously marked as enabled. However,</span></li><li>  <span class=\"hljs-comment\">//the dependencies are not known until init is called. So</span></li><li>  <span class=\"hljs-comment\">//if enabled previously, now trigger dependencies as enabled.</span></li><li>  <span class=\"hljs-keyword\">if</span> (options.enabled || <span class=\"hljs-keyword\">this</span>.enabled) {</li><li>    <span class=\"hljs-comment\">//Enable this module and dependencies.</span></li><li>    <span class=\"hljs-comment\">//Will call this.check()</span></li><li>    <span class=\"hljs-keyword\">this</span>.enable();</li><li>  } <span class=\"hljs-keyword\">else</span> {</li><li>    <span class=\"hljs-keyword\">this</span>.check();</li><li>  }</li><li>}</li></ul></code></pre><p><span>这里前面主要是根据实例的内部参数配置参数，关键是最后那个<code>if</code>，假如输入参数<code>option.enabled = true</code>，那么就会直接调用<code>this.enable()</code>，这个方法主要是一些错误检查，无误之后将会跳转到<code>this.fetch()</code>方法，源码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li></ul><ul class=\"code\"><li>Module.prototype.fetch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.fetched) {</li><li>    <span class=\"hljs-keyword\">return</span>;</li><li>  }</li><li>  <span class=\"hljs-keyword\">this</span>.fetched = <span class=\"hljs-literal\">true</span>;</li><li></li><li>  context.startTime = (<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()).getTime();</li><li></li><li>  <span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">this</span>.map;</li><li></li><li>  <span class=\"hljs-comment\">//If the manager is for a plugin managed resource,</span></li><li>  <span class=\"hljs-comment\">//ask the plugin to load it now.</span></li><li>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.shim) {</li><li>    context.makeRequire(<span class=\"hljs-keyword\">this</span>.map, {</li><li>      <span class=\"hljs-attr\">enableBuildCallback</span>: <span class=\"hljs-literal\">true</span></li><li>    })(<span class=\"hljs-keyword\">this</span>.shim.deps || [], bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>      <span class=\"hljs-keyword\">return</span> map.prefix ? <span class=\"hljs-keyword\">this</span>.callPlugin() : <span class=\"hljs-keyword\">this</span>.load();</li><li>    }));</li><li>  } <span class=\"hljs-keyword\">else</span> {</li><li>    <span class=\"hljs-comment\">//Regular dependency.</span></li><li>    <span class=\"hljs-keyword\">return</span> map.prefix ? <span class=\"hljs-keyword\">this</span>.callPlugin() : <span class=\"hljs-keyword\">this</span>.load();</li><li>  }</li><li>}</li></ul></code></pre><p><span>这里值得注意的是，有一个<code>prefix</code>的参数，这个是当前模块的前置依赖，要是它存在，那么会先加载那个模块，然后再加载当前模块。</span><span>初次调用肯定是不存在的，那么将会继续跳转至<code>this.load()</code>，这里面将会把马上就要载入模块的名字和路径当作参数继续跳转，然后将会到达<code>req.load(context, id, url)</code>方法，源码很长，但其实都是一些浏览器的兼容处理，最后将会调用<code>node = req.createNode(config, moduleName, url)</code>添加标签。你以为完了吗？还没有呢，之后会马上给标签绑定上两个事件：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li></ul><ul class=\"code\"><li>node.addEventListener(<span class=\"hljs-string\">'load'</span>, context.onScriptLoad, <span class=\"hljs-literal\">false</span>);</li><li>node.addEventListener(<span class=\"hljs-string\">'error'</span>, context.onScriptError, <span class=\"hljs-literal\">false</span>);</li></ul></code></pre><p><span>一个在加载完成后，一个在加载出错时。</span><span>前者是读取新添加脚本的内容，后者是抛出加载错误的异常。</span></p><h2 id=\"加载检查\">加载检查</h2><p><span>当然，不是说添加了<code>script</code>标签就完了，肯定要监控脚本是否正常加载了。所以有一个加载检查的函数<code>checkLoaded()</code>，虽然源码很长，但是功能挺简单，就不贴代码了，其功能就是间隔50毫秒的异步轮询，如果没有成功加载那么继续监控，如果超过一定时间还未成功，那么就要抛出超时错误。</span><span>至此，终于理顺了初始化过程，对整个 <code>requirejs</code>模块的大致解构也有了点初步的了解，接下来看看对外暴露的几个方法。</span></p><h1 id=\"require.config\">require.config</h1><p><span>这个方法会直接调用内部的<code>req.config()</code>方法，而后进一步调用<code>reg()</code>，将参数保存至内部<code>context</code>。但是我比较疑惑的就是它仍然会<code>require</code>本身，并制作<code>Module</code>，甚至于后面的异步调用都有参与，虽然说是空的<code>Moudle</code>，并且未计入全局<code>Module</code>列表中，但是程序如此设计不是多此一举吗？</span></p><h1 id=\"require\">require</h1><p><span>其实在<code>requirejs</code>本身初始化的过程中就是使用这个命令，它不过是将自己作为了一个特殊的模块，初始化首先处理了自己本身的属性，然后<code>require</code>了它自己。</span><span>先来介绍一下内部用于保存模块的类——<code>Module</code>。</span></p><h2 id=\"Module类\"><code>Module</code>类</h2><p><span>这个类是<code>requirejs</code>内部自己定义的类，用于保存依赖的模块，它的原型是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul><ul class=\"code\"><li>Module = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">map</span>) </span>{</li><li>  <span class=\"hljs-keyword\">this</span>.events = getOwn(undefEvents, map.id) || {};</li><li>  <span class=\"hljs-keyword\">this</span>.map = map;</li><li>  <span class=\"hljs-keyword\">this</span>.shim = getOwn(config.shim, map.id);</li><li>  <span class=\"hljs-keyword\">this</span>.depExports = [];</li><li>  <span class=\"hljs-keyword\">this</span>.depMaps = [];</li><li>  <span class=\"hljs-keyword\">this</span>.depMatched = [];</li><li>  <span class=\"hljs-keyword\">this</span>.pluginMaps = {};</li><li>  <span class=\"hljs-keyword\">this</span>.depCount = <span class=\"hljs-number\">0</span>;</li><li></li><li>  <span class=\"hljs-comment\">/* this.exports this.factory</li><li>   this.depMaps = [],</li><li>   this.enabled, this.fetched</li><li>   */</span></li><li>}</li></ul></code></pre><p><span>每一个依赖都有很多状态，比如<code>loading</code>, <code>enabling</code>, <code>defining</code>，即加载模块文件，使能该模块（运行模块内部的<code>define</code>），最后是正在运行<code>callback</code>。</span><span>当新建一个模块之后就会立刻运行<code>init()</code>，然后根据不同的配置和状态转向不同的方法，比如当前模块的依赖还没有加载，那么就会转向<code>enable()</code>，如果依赖加载完毕，那就会转向<code>check()</code>，如果状态变成了<code>defined</code>，就表示整个模块都运行完了（包括输入的回调）。</span><span>这些状态在初始化的时候并未定义，只有在下面的各个方法中可以看到。</span></p><h2 id=\"具体过程\">具体过程</h2><p><span>对于外部使用而言，其过程和<code>data-main</code>初始化大同小异，在这里再稍微提一下。</span><span>对外暴露的<code>require</code>会直接调用<code>req()</code>方法，根据规则跳过中间那么多处理之后，会转入<code>localRequire()</code>，在其中啥事儿没干，就是定义了那个<code>nextTick()</code>的异步函数。</span><span>从时间顺序上来讲，脚本读取完成之后将会触发添加脚本时候添加的<code>load</code>事件，对于<code>require</code>事件而言，也啥都没干……进去跑了一圈就出来了。所以这里也不贴源码了，在<code>define</code>有详细介绍。</span><span>间隔几个毫秒之后就是<code>nextTick()</code>异步函数，这才是主要的，异步函数中最主要的就是以<code>enabled: true</code>为参数初始化，即执行<code>init()</code>方法。如果<code>require</code>内部有依赖，那么将会保存当前数据，并紧接着去加载它的依赖，有关这一点之后再讲，现在假设没有任何依赖或者说依赖已经加载完成了，有没有完成加载依赖的主要区别都在<code>Module.check()</code>函数中，它的源码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li>51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li><li>68</li><li>69</li><li>70</li><li>71</li><li>72</li><li>73</li><li>74</li><li>75</li><li>76</li><li>77</li><li>78</li><li>79</li><li>80</li><li>81</li><li>82</li><li>83</li><li>84</li><li>85</li><li>86</li><li>87</li><li>88</li><li>89</li><li>90</li><li>91</li><li>92</li><li>93</li><li>94</li><li>95</li><li>96</li><li>97</li><li>98</li><li>99</li><li>100</li><li>101</li><li>102</li><li>103</li><li>104</li><li>105</li><li>106</li></ul><ul class=\"code\"><li><span class=\"hljs-comment\">/**</li><li> * Checks if the module is ready to define itself, and if so,</li><li> * define it.</li><li> */</span></li><li>Module.prototype.check = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.enabled || <span class=\"hljs-keyword\">this</span>.enabling) {</li><li>    <span class=\"hljs-keyword\">return</span>;</li><li>  }</li><li></li><li>  <span class=\"hljs-keyword\">var</span> err, cjsModule,</li><li>    id = <span class=\"hljs-keyword\">this</span>.map.id,</li><li>    depExports = <span class=\"hljs-keyword\">this</span>.depExports,</li><li>    exports = <span class=\"hljs-keyword\">this</span>.exports,</li><li>    factory = <span class=\"hljs-keyword\">this</span>.factory;</li><li></li><li>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.inited) {</li><li>    <span class=\"hljs-comment\">// Only fetch if not already in the defQueue.</span></li><li>    <span class=\"hljs-keyword\">if</span> (!hasProp(context.defQueueMap, id)) {</li><li>      <span class=\"hljs-keyword\">this</span>.fetch();</li><li>    }</li><li>  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.error) {</li><li>    <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-keyword\">this</span>.error);</li><li>  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.defining) {</li><li>    <span class=\"hljs-comment\">//The factory could trigger another require call</span></li><li>    <span class=\"hljs-comment\">//that would result in checking this module to</span></li><li>    <span class=\"hljs-comment\">//define itself again. If already in the process</span></li><li>    <span class=\"hljs-comment\">//of doing that, skip this work.</span></li><li>    <span class=\"hljs-keyword\">this</span>.defining = <span class=\"hljs-literal\">true</span>;</li><li></li><li>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.depCount &lt; <span class=\"hljs-number\">1</span> &amp;&amp; !<span class=\"hljs-keyword\">this</span>.defined) {</li><li>      <span class=\"hljs-keyword\">if</span> (isFunction(factory)) {</li><li>        <span class=\"hljs-comment\">//If there is an error listener, favor passing</span></li><li>        <span class=\"hljs-comment\">//to that instead of throwing an error. However,</span></li><li>        <span class=\"hljs-comment\">//only do it for define()'d  modules. require</span></li><li>        <span class=\"hljs-comment\">//errbacks should not be called for failures in</span></li><li>        <span class=\"hljs-comment\">//their callbacks (#699). However if a global</span></li><li>        <span class=\"hljs-comment\">//onError is set, use that.</span></li><li>        <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-keyword\">this</span>.events.error &amp;&amp; <span class=\"hljs-keyword\">this</span>.map.isDefine) ||</li><li>          req.onError !== defaultOnError) {</li><li>          <span class=\"hljs-keyword\">try</span> {</li><li>            exports = context.execCb(id, factory, depExports, exports);</li><li>          } <span class=\"hljs-keyword\">catch</span> (e) {</li><li>            err = e;</li><li>          }</li><li>        } <span class=\"hljs-keyword\">else</span> {</li><li>          exports = context.execCb(id, factory, depExports, exports);</li><li>        }</li><li></li><li>        <span class=\"hljs-comment\">// Favor return value over exports. If node/cjs in play,</span></li><li>        <span class=\"hljs-comment\">// then will not have a return value anyway. Favor</span></li><li>        <span class=\"hljs-comment\">// module.exports assignment over exports object.</span></li><li>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.map.isDefine &amp;&amp; exports === <span class=\"hljs-literal\">undefined</span>) {</li><li>          cjsModule = <span class=\"hljs-keyword\">this</span>.module;</li><li>          <span class=\"hljs-keyword\">if</span> (cjsModule) {</li><li>            exports = cjsModule.exports;</li><li>          } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.usingExports) {</li><li>            <span class=\"hljs-comment\">//exports already set the defined value.</span></li><li>            exports = <span class=\"hljs-keyword\">this</span>.exports;</li><li>          }</li><li>        }</li><li></li><li>        <span class=\"hljs-keyword\">if</span> (err) {</li><li>          err.requireMap = <span class=\"hljs-keyword\">this</span>.map;</li><li>          err.requireModules = <span class=\"hljs-keyword\">this</span>.map.isDefine ? [<span class=\"hljs-keyword\">this</span>.map.id] : <span class=\"hljs-literal\">null</span>;</li><li>          err.requireType = <span class=\"hljs-keyword\">this</span>.map.isDefine ? <span class=\"hljs-string\">'define'</span> : <span class=\"hljs-string\">'require'</span>;</li><li>          <span class=\"hljs-keyword\">return</span> onError((<span class=\"hljs-keyword\">this</span>.error = err));</li><li>        }</li><li></li><li>      } <span class=\"hljs-keyword\">else</span> {</li><li>        <span class=\"hljs-comment\">//Just a literal value</span></li><li>        exports = factory;</li><li>      }</li><li></li><li>      <span class=\"hljs-keyword\">this</span>.exports = exports;</li><li></li><li>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.map.isDefine &amp;&amp; !<span class=\"hljs-keyword\">this</span>.ignore) {</li><li>        defined[id] = exports;</li><li></li><li>        <span class=\"hljs-keyword\">if</span> (req.onResourceLoad) {</li><li>          <span class=\"hljs-keyword\">var</span> resLoadMaps = [];</li><li>          each(<span class=\"hljs-keyword\">this</span>.depMaps, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">depMap</span>) </span>{</li><li>            resLoadMaps.push(depMap.normalizedMap || depMap);</li><li>          });</li><li>          req.onResourceLoad(context, <span class=\"hljs-keyword\">this</span>.map, resLoadMaps);</li><li>        }</li><li>      }</li><li></li><li>      <span class=\"hljs-comment\">//Clean up</span></li><li>      cleanRegistry(id);</li><li></li><li>      <span class=\"hljs-keyword\">this</span>.defined = <span class=\"hljs-literal\">true</span>;</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//Finished the define stage. Allow calling check again</span></li><li>    <span class=\"hljs-comment\">//to allow define notifications below in the case of a</span></li><li>    <span class=\"hljs-comment\">//cycle.</span></li><li>    <span class=\"hljs-keyword\">this</span>.defining = <span class=\"hljs-literal\">false</span>;</li><li></li><li>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.defined &amp;&amp; !<span class=\"hljs-keyword\">this</span>.defineEmitted) {</li><li>      <span class=\"hljs-keyword\">this</span>.defineEmitted = <span class=\"hljs-literal\">true</span>;</li><li>      <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-string\">'defined'</span>, <span class=\"hljs-keyword\">this</span>.exports);</li><li>      <span class=\"hljs-keyword\">this</span>.defineEmitComplete = <span class=\"hljs-literal\">true</span>;</li><li>    }</li><li></li><li>  }</li><li>}</li></ul></code></pre><p><span>如果说依赖没有加载完，那么当前<code>Module</code>对象必然有<code>inited = undefined</code>，所以就会转入<code>Module.fetch()</code>方法中去加载依赖，当<code>inited = true</code>，那么表示当前<code>Module</code>对象加载完成了，可以执行回调，那么将会把参数一股脑传入<code>context.execCb</code>函数中，这个函数很短：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li></ul><ul class=\"code\"><li>execCb: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name, callback, args, exports</span>) </span>{</li><li>    <span class=\"hljs-keyword\">return</span> callback.apply(exports, args);</li><li>}</li></ul></code></pre><p><span>可以看到，这里就会执行回调了。</span></p><h1 id=\"define\"><code>define</code></h1><p><span>再来说说<code>define</code>，它的源码其实并不长：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li>51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li></ul><ul class=\"code\"><li>define = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name, deps, callback</span>) </span>{</li><li>    <span class=\"hljs-keyword\">var</span> node, context;</li><li></li><li>    <span class=\"hljs-comment\">//Allow for anonymous modules</span></li><li>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> name !== <span class=\"hljs-string\">'string'</span>) {</li><li>        <span class=\"hljs-comment\">//Adjust args appropriately</span></li><li>        callback = deps;</li><li>        deps = name;</li><li>        name = <span class=\"hljs-literal\">null</span>;</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//This module may not have dependencies</span></li><li>    <span class=\"hljs-keyword\">if</span> (!isArray(deps)) {</li><li>        callback = deps;</li><li>        deps = <span class=\"hljs-literal\">null</span>;</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//If no name, and callback is a function, then figure out if it a</span></li><li>    <span class=\"hljs-comment\">//CommonJS thing with dependencies.</span></li><li>    <span class=\"hljs-keyword\">if</span> (!deps &amp;&amp; isFunction(callback)) {</li><li>        deps = [];</li><li>        <span class=\"hljs-comment\">//Remove comments from the callback string,</span></li><li>        <span class=\"hljs-comment\">//look for require calls, and pull them into the dependencies,</span></li><li>        <span class=\"hljs-comment\">//but only if there are function args.</span></li><li>        <span class=\"hljs-keyword\">if</span> (callback.length) {</li><li>            callback</li><li>                .toString()</li><li>                .replace(commentRegExp, commentReplace)</li><li>                .replace(cjsRequireRegExp, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">match, dep</span>) </span>{</li><li>                    deps.push(dep);</li><li>                });</li><li></li><li>            <span class=\"hljs-comment\">//May be a CommonJS thing even without require calls, but still</span></li><li>            <span class=\"hljs-comment\">//could use exports, and module. Avoid doing exports and module</span></li><li>            <span class=\"hljs-comment\">//work though if it just needs require.</span></li><li>            <span class=\"hljs-comment\">//REQUIRES the function to expect the CommonJS variables in the</span></li><li>            <span class=\"hljs-comment\">//order listed below.</span></li><li>            deps = (callback.length === <span class=\"hljs-number\">1</span> ? [<span class=\"hljs-string\">'require'</span>] : </li><li>                [<span class=\"hljs-string\">'require'</span>, <span class=\"hljs-string\">'exports'</span>, <span class=\"hljs-string\">'module'</span>]).concat(deps);</li><li>        }</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//If in IE 6-8 and hit an anonymous define() call, do the interactive</span></li><li>    <span class=\"hljs-comment\">//work.</span></li><li>    <span class=\"hljs-keyword\">if</span> (useInteractive) {</li><li>        node = currentlyAddingScript || getInteractiveScript();</li><li>        <span class=\"hljs-keyword\">if</span> (node) {</li><li>            <span class=\"hljs-keyword\">if</span> (!name) {</li><li>                name = node.getAttribute(<span class=\"hljs-string\">'data-requiremodule'</span>);</li><li>            }</li><li>            context = contexts[node.getAttribute(<span class=\"hljs-string\">'data-requirecontext'</span>)];</li><li>        }</li><li>    }</li><li></li><li>    <span class=\"hljs-comment\">//Always save off evaluating the def call until the script onload handler.</span></li><li>    <span class=\"hljs-comment\">//This allows multiple modules to be in a file without prematurely</span></li><li>    <span class=\"hljs-comment\">//tracing dependencies, and allows for anonymous module support,</span></li><li>    <span class=\"hljs-comment\">//where the module name is not known until the script onload event</span></li><li>    <span class=\"hljs-comment\">//occurs. If no context, use the global queue, and get it processed</span></li><li>    <span class=\"hljs-comment\">//in the onscript load callback.</span></li><li>    <span class=\"hljs-keyword\">if</span> (context) {</li><li>        context.defQueue.push([name, deps, callback]);</li><li>        context.defQueueMap[name] = <span class=\"hljs-literal\">true</span>;</li><li>    } <span class=\"hljs-keyword\">else</span> {</li><li>        globalDefQueue.push([name, deps, callback]);</li><li>    }</li><li>}</li></ul></code></pre><p><span>脚本加载完成之后，就会读取脚本的内容，碰到<code>define</code>命令就会运行这里的代码，可以看出<code>define</code>命令仅仅是做了很多兼容处理，然后就将所有信息暂存进了两个全局队列。在这里有一处值得注意，就是对<code>callback</code>的正则处理，<code>callback</code>转为字符串之后连续两次调用<code>replace()</code>方法，其中的正则是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li></ul><ul class=\"code\"><li>commentRegExp = <span class=\"hljs-regexp\">/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/</span>;</li><li>mgcjsRequireRegExp = <span class=\"hljs-regexp\">/[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g</span>;</li></ul></code></pre><p><span>上面那个看名字都能看出是匹配代码中的所有注释，后者则是匹配了<code>require(/*code*/)</code>这样的结构，并将<code>require()</code>内的内容存了起来。很明显了，这里肯定是此模块的依赖，当然要先存起来等待之后加载的。脚本一旦读取完成，就会触发当初添加脚本时候添加的<code>load</code>事件，<code>context.onScriptLoad()</code>，此事件的源码并不长功能也简单，先是移除了开始给脚本绑定的那两个事件，随后调用了<code>context.completeLoad()</code>方法，后者的源码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li></ul><ul class=\"code\"><li>completeLoad: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">moduleName</span>) </span>{</li><li>    <span class=\"hljs-keyword\">var</span> found, args, mod,</li><li>        shim = getOwn(config.shim, moduleName) || {},</li><li>        shExports = shim.exports;</li><li></li><li>    takeGlobalQueue();</li><li></li><li>    <span class=\"hljs-keyword\">while</span> (defQueue.length) {</li><li>        args = defQueue.shift();</li><li>        <span class=\"hljs-keyword\">if</span> (args[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-literal\">null</span>) {</li><li>            args[<span class=\"hljs-number\">0</span>] = moduleName;</li><li>            <span class=\"hljs-comment\">//If already found an anonymous module and bound it</span></li><li>            <span class=\"hljs-comment\">//to this name, then this is some other anon module</span></li><li>            <span class=\"hljs-comment\">//waiting for its completeLoad to fire.</span></li><li>            <span class=\"hljs-keyword\">if</span> (found) {</li><li>                <span class=\"hljs-keyword\">break</span>;</li><li>            }</li><li>            found = <span class=\"hljs-literal\">true</span>;</li><li>        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (args[<span class=\"hljs-number\">0</span>] === moduleName) {</li><li>            <span class=\"hljs-comment\">//Found matching define call for this script!</span></li><li>            found = <span class=\"hljs-literal\">true</span>;</li><li>        }</li><li></li><li>        callGetModule(args);</li><li>    }</li><li>    context.defQueueMap = {};</li><li></li><li>    <span class=\"hljs-comment\">//Do this after the cycle of callGetModule in case the result</span></li><li>    <span class=\"hljs-comment\">//of those calls/init calls changes the registry.</span></li><li>    mod = getOwn(registry, moduleName);</li><li></li><li>    <span class=\"hljs-keyword\">if</span> (!found &amp;&amp; !hasProp(defined, moduleName) &amp;&amp; mod &amp;&amp; !mod.inited) {</li><li>        <span class=\"hljs-keyword\">if</span> (config.enforceDefine &amp;&amp; (!shExports || !getGlobal(shExports))) {</li><li>            <span class=\"hljs-keyword\">if</span> (hasPathFallback(moduleName)) {</li><li>                <span class=\"hljs-keyword\">return</span>;</li><li>            } <span class=\"hljs-keyword\">else</span> {</li><li>                <span class=\"hljs-keyword\">return</span> onError(makeError(<span class=\"hljs-string\">'nodefine'</span>,</li><li>                    <span class=\"hljs-string\">'No define call for '</span> + moduleName,</li><li>                    <span class=\"hljs-literal\">null</span>,</li><li>                    [moduleName]));</li><li>            }</li><li>        } <span class=\"hljs-keyword\">else</span> {</li><li>            <span class=\"hljs-comment\">//A script that does not call define(), so just simulate</span></li><li>            <span class=\"hljs-comment\">//the call for it.</span></li><li>            callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);</li><li>        }</li><li>    }</li><li></li><li>    checkLoaded();</li><li>}</li></ul></code></pre><p><span>很明显，这里先取出了之前读取文件内容后保存在全局队列中相关的记录，然后调用了<code>callGetModule()</code>，它的代码是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul><ul class=\"code\"><li><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callGetModule</span>(<span class=\"hljs-params\">args</span>) </span>{</li><li>    <span class=\"hljs-comment\">//Skip modules already defined.</span></li><li>    <span class=\"hljs-keyword\">if</span> (!hasProp(defined, args[<span class=\"hljs-number\">0</span>])) {        </li><li>        getModule(</li><li>            makeModuleMap(args[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">true</span>)).init(args[<span class=\"hljs-number\">1</span>], args[<span class=\"hljs-number\">2</span>]</li><li>        );    </li><li>    }</li><li>}</li></ul></code></pre><p><span>很眼熟吧，在<code>require</code>的那个异步函数中也有这么一段，这一段的意思注释也说的很清楚了，就是如果<code>defined</code>中已经存了当前模块的信息，说明之前已经加载过啦，就跳过，如果还没有，那就新建一个，并且将之初始化，这个初始化的方法<code>init()</code>，在上面也提过了不多讲。</span></p><h1 id=\"依赖的依赖\">依赖的依赖</h1><p><span>在平时的使用中，依赖本身还包含了别的依赖也是很常见的情况。对于这种情况无论是<code>define</code>还是<code>require</code>处理过程都是一样的，毕竟两个模块都是以<code>init()</code>为入口的，所以这里就放在一起讲了。</span><span>还是从<code>init()</code>开始，之后将会跳转到<code>enable()</code>方法，没有依赖的时候，<code>enable()</code>方法几乎不做任何处理就直接跳转到了<code>check()</code>方法。</span><span>这里我们当然假设是有依赖的，那么看它的源码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li>51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li><li>68</li><li>69</li><li>70</li><li>71</li><li>72</li><li>73</li><li>74</li><li>75</li><li>76</li></ul><ul class=\"code\"><li>Module.prototype.enable = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</li><li>    enabledRegistry[<span class=\"hljs-keyword\">this</span>.map.id] = <span class=\"hljs-keyword\">this</span>;</li><li>    <span class=\"hljs-keyword\">this</span>.enabled = <span class=\"hljs-literal\">true</span>;</li><li></li><li>    <span class=\"hljs-comment\">//Set flag mentioning that the module is enabling,</span></li><li>    <span class=\"hljs-comment\">//so that immediate calls to the defined callbacks</span></li><li>    <span class=\"hljs-comment\">//for dependencies do not trigger inadvertent load</span></li><li>    <span class=\"hljs-comment\">//with the depCount still being zero.</span></li><li>    <span class=\"hljs-keyword\">this</span>.enabling = <span class=\"hljs-literal\">true</span>;</li><li></li><li>    <span class=\"hljs-comment\">//Enable each dependency</span></li><li>    each(<span class=\"hljs-keyword\">this</span>.depMaps, bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">depMap, i</span>) </span>{</li><li>        <span class=\"hljs-keyword\">var</span> id, mod, handler;</li><li></li><li>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> depMap === <span class=\"hljs-string\">'string'</span>) {</li><li>            <span class=\"hljs-comment\">//Dependency needs to be converted to a depMap</span></li><li>            <span class=\"hljs-comment\">//and wired up to this module.</span></li><li>            depMap = makeModuleMap(depMap,</li><li>                (<span class=\"hljs-keyword\">this</span>.map.isDefine ? <span class=\"hljs-keyword\">this</span>.map : <span class=\"hljs-keyword\">this</span>.map.parentMap),</li><li>                <span class=\"hljs-literal\">false</span>,</li><li>                !<span class=\"hljs-keyword\">this</span>.skipMap);</li><li>            <span class=\"hljs-keyword\">this</span>.depMaps[i] = depMap;</li><li></li><li>            handler = getOwn(handlers, depMap.id);</li><li></li><li>            <span class=\"hljs-keyword\">if</span> (handler) {</li><li>                <span class=\"hljs-keyword\">this</span>.depExports[i] = handler(<span class=\"hljs-keyword\">this</span>);</li><li>                <span class=\"hljs-keyword\">return</span>;</li><li>            }</li><li></li><li>            <span class=\"hljs-keyword\">this</span>.depCount += <span class=\"hljs-number\">1</span>;</li><li></li><li>            on(depMap, <span class=\"hljs-string\">'defined'</span>, bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">depExports</span>) </span>{</li><li>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.undefed) {</li><li>                    <span class=\"hljs-keyword\">return</span>;</li><li>                }</li><li>                <span class=\"hljs-keyword\">this</span>.defineDep(i, depExports);</li><li>                <span class=\"hljs-keyword\">this</span>.check();</li><li>            }));</li><li></li><li>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.errback) {</li><li>                on(depMap, <span class=\"hljs-string\">'error'</span>, bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.errback));</li><li>            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.events.error) {</li><li>                <span class=\"hljs-comment\">// No direct errback on this module, but something</span></li><li>                <span class=\"hljs-comment\">// else is listening for errors, so be sure to</span></li><li>                <span class=\"hljs-comment\">// propagate the error correctly.</span></li><li>                on(depMap, <span class=\"hljs-string\">'error'</span>, bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{</li><li>                    <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-string\">'error'</span>, err);</li><li>                }));</li><li>            }</li><li>        }</li><li></li><li>        id = depMap.id;</li><li>        mod = registry[id];</li><li></li><li>        <span class=\"hljs-comment\">//Skip special modules like 'require', 'exports', 'module'</span></li><li>        <span class=\"hljs-comment\">//Also, don't call enable if it is already enabled,</span></li><li>        <span class=\"hljs-comment\">//important in circular dependency cases.</span></li><li>        <span class=\"hljs-keyword\">if</span> (!hasProp(handlers, id) &amp;&amp; mod &amp;&amp; !mod.enabled) {</li><li>            context.enable(depMap, <span class=\"hljs-keyword\">this</span>);</li><li>        }</li><li>    }));</li><li></li><li>    <span class=\"hljs-comment\">//Enable each plugin that is used in</span></li><li>    <span class=\"hljs-comment\">//a dependency</span></li><li>    eachProp(<span class=\"hljs-keyword\">this</span>.pluginMaps, bind(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">pluginMap</span>) </span>{</li><li>        <span class=\"hljs-keyword\">var</span> mod = getOwn(registry, pluginMap.id);</li><li>        <span class=\"hljs-keyword\">if</span> (mod &amp;&amp; !mod.enabled) {</li><li>            context.enable(pluginMap, <span class=\"hljs-keyword\">this</span>);</li><li>        }</li><li>    }));</li><li></li><li>    <span class=\"hljs-keyword\">this</span>.enabling = <span class=\"hljs-literal\">false</span>;</li><li></li><li>    <span class=\"hljs-keyword\">this</span>.check();</li><li>}</li></ul></code></pre><p><span><code>this. depMaps</code>就记录着当前模块的依赖，<code>bind()</code>函数只是在其中又套了一层函数，不知是为什么，<code>each()</code>将会遍历它的第一个输入参数，将它们每一个都做为第二个参数（函数）的参数，然后运行第二个参数（函数）。总之就是用那个回调函数对第一个参数里面的每一个数据都运行一次。</span><span>接下来的挺好懂，<code>depMap</code>就是当前依赖的模块名字，根据规则<code>new Module()</code>，然后配置之，接下来是<code>on()</code>，这个方法代码不长，但是里面套了几层，最后到了这里：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><ul class=\"code\"><li>on: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name, cb</span>) </span>{</li><li>    <span class=\"hljs-keyword\">var</span> cbs = <span class=\"hljs-keyword\">this</span>.events[name];</li><li>    <span class=\"hljs-keyword\">if</span> (!cbs) {</li><li>        cbs = <span class=\"hljs-keyword\">this</span>.events[name] = [];</li><li>    }</li><li>    cbs.push(cb);</li><li>}</li></ul></code></pre><p><span>简而言之它把后面<code>bind</code>里面那个回调函数外带现在的输入参数给存了起来，注意，此时并没有运行。</span><span>随后便是<code>context.enable()</code>，这个方法的源码：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul><ul class=\"code\"><li>enable: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">depMap</span>) </span>{</li><li>    <span class=\"hljs-keyword\">var</span> mod = getOwn(registry, depMap.id);</li><li>    <span class=\"hljs-keyword\">if</span> (mod) {</li><li>        getModule(depMap).enable();</li><li>    }</li><li>}</li></ul></code></pre><p><span>很明显就是加载这个新的依赖。这个新的依赖加载完成之后，依旧触发<code>completeload()</code>，然后就取出模块去<code>init()</code>，中间的过程省略了，反正最后跳转到了<code>check()</code>那里，在这里将会运行它的回调，然后不同的地方在这里，<code>check()</code>最后是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul><ul class=\"code\"><li><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.defined &amp;&amp; !<span class=\"hljs-keyword\">this</span>.defineEmitted) {</li><li>    <span class=\"hljs-keyword\">this</span>.defineEmitted = <span class=\"hljs-literal\">true</span>;</li><li>    <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-string\">'defined'</span>, <span class=\"hljs-keyword\">this</span>.exports);    </li><li>    <span class=\"hljs-keyword\">this</span>.defineEmitComplete = <span class=\"hljs-literal\">true</span>;</li><li>}</li></ul></code></pre><p><span><code>defined</code>表示当前依赖的回调已经运行完了，以后都不关它的事儿了，随后将会进<code>this.emit()</code>，它的代码是这样的：</span></p><pre class=\"javascript\"><code><ul class=\"gutter\"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li></ul><ul class=\"code\"><li>emit: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name, evt</span>) </span>{</li><li>    each(<span class=\"hljs-keyword\">this</span>.events[name], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cb</span>) </span>{</li><li>        cb(evt);    </li><li>    });</li><li>    <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">'error'</span>) {</li><li>        <span class=\"hljs-comment\">//Now that the error handler was triggered, remove</span></li><li>        <span class=\"hljs-comment\">//the listeners, since this broken Module instance</span></li><li>        <span class=\"hljs-comment\">//can stay around for a while in the registry.        </span></li><li>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>.events[name];</li><li>    }</li><li>}</li></ul></code></pre><p><span>是不是很眼熟啊，和上面那个<code>this.on</code>的代码很像吧，不过刚好反了过来，<code>this.on</code>将参数和回调都存了起来，这里就会挨着全部取出来并且依次运行，就这样一层一层的运行。</span></p><p><span>所以，看明白了吗。简而言之就是加入碰到了需要加载的依赖，会将当前数据全部保存起来，然后去加载新的依赖，直到最后碰到一个不需要加载依赖的模块，此时这个模块将会被首先标记为<code>initd =  true</code>，然后执行它的回调，执行完成之后将会从全局变量中依次取出之前的数据，挨个运行回调。</span><span>这个方式很眼熟吧，其实就是递归。<code>requirejs</code>调用模块的本质就是递归调用，不过却不是程序自动调用递归，而是完全手动管理的递归调用。之所以要用手工管理，我想大概是因为依赖模块的加载全部都是异步的，不可能用同步的方法阻塞程序运行。也正是因为这种异步+递归的编程思路，让我觉得这个代码实在是比较难以理解……</span></p><h1 id=\"总结\">总结</h1><ol><li><p><span>从编程风格上来说<code>requirejs</code>模块的代码虽然少，但是构思非常巧妙，采用了手工管理的递归+异步的编程方式，导致代码理解起来比较困难，再加上其中为了保护内部数据，采用了大量的闭包，无处不在的回调，让我比较头晕。</span></p></li><li><p><span>从结构上来说，源码中最大的部分就是<code>newContext()</code>，这里面定义了一个通用<code>Module</code>类，大量的工具函数，并维护了一个存有诸多临时变量的闭包。</span></p></li><li><p><span>初始化的过程其实就是把<code>data-main</code>当作一个特殊的依赖来处理的。</span></p></li><li><p><span><code>define</code>和<code>require</code>虽然都是在最后执行回调，但是两者执行的时间其实不一样，<code>define</code>是在最后触发<code>completeload()</code>事件的最后执行回调，而<code>require</code>是在最开始定义的延迟4ms的延迟函数里面执行回调，从事件上来说，<code>completeload()</code>事件肯定要早于<code>require</code>的异步事件。</span></p></li><li><p><span>我也只是很浅显的读了读代码，不敢保证完全正确，如果有错误还望指正……另外还有些地方不甚明了，比如<code>require.config</code>的那个问题……以后有机会再看吧。以上！</span></p></li></ol>"}