<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>++[] 与 ++[[]][0]</title><meta name="description" content="闲言碎语"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/img/favicon.ico"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.dreamingcat.me/atom.xml" title="Dreaming Cat's"></head><body><header><div><div id="logo-img"><a href="/"><img src="/img/logo.png" alt="Dreaming Cat's" title="Dreaming Cat's"></a></div><div id="logo-text"><h1><a href="/" title="Dreaming Cat's">Dreaming Cat's</a></h1><h2>梦之上</h2></div><ul id="logo-list"><li><a href="/">主页</a></li><li><a href="/archives/">归档</a></li><li><a href="/categories/">分类</a></li><li><a href="/tags/">标签</a></li><li><a href="/archives/about/">关于</a></li><li><form class="search" action="//google.com/search" method="get" accept-charset="utf-8"><input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索"></form></li></ul></div></header><article id="container"><div class="post" id="main"><header><p>++[] 与 ++[[]][0]</p><p>发表于：2016-10-10</p></header><article class="post-content"><h1 id="简述">简述</h1><p><span>对于<code>++[[]][0]</code>这个表达式，<code>[]</code>运算符的优先级比<code>++</code>要高，所以首先会运算<code>[[]][0]</code>，这里就是对<code>[[]]</code>数组取下标为<code>0</code>的元素，也就是它内部的<code>[]</code>，所以这个表达式就变成了<code>++[]</code>。但是为什么<code>++[]</code>和<code>++[[]][0]</code>的运行结果却不一样？</span></p><pre class="javascript"><code><ul class="gutter"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul><ul class="code"><li>++[]</li><li><span class="hljs-comment">//Uncaught ReferenceError: Invalid left-hand side expression</span></li><li></li><li>++[[]][<span class="hljs-number">0</span>]</li><li><span class="hljs-comment">//1</span></li></ul></code></pre><p><span>前者抛出了引用错误，而后者却返回了个值，为什么会是这样？</span><span><code>++</code>运算符是自加运算，因此它必须跟着变量而不是常量，所以<code>++[]</code>报错了，这是符合直觉的；然而这并不能解释<code>++[[]][0]</code>为什么没有报错，毕竟<code>[[]][0]</code>这也是个常量啊。</span></p><p><span>先看看这个引用错误<code>ReferenceError</code>，它的说明是<code>Invalid left-hand side expression</code>，也就是<strong><em>无效的左值表达式</em></strong>，这个错误通常并不是运行的时候抛出的，而是在运行前编译阶段抛出的。这就说明这个语句本身是不符合句法规范的。</span></p><p><span>有了这个突破口，我们就先来看看正确的句法规范是怎么样的。</span></p><h1 id="句法结构">句法结构</h1><p><span>首先对这两句话构建语法树，按照成分将它们拆分开来，在这里使用的工具是<code>uglify-js</code>，结果如下：</span></p><pre class="javascript"><code><ul class="gutter"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li></ul><ul class="code"><li><span class="hljs-comment">//语句</span></li><li>++[[]][<span class="hljs-number">0</span>]</li><li><span class="hljs-comment">//语法树</span></li><li>ast = {</li><li>    <span class="hljs-attr">type</span>: <span class="hljs-string">"program"</span>,</li><li>    <span class="hljs-attr">body</span>: [{</li><li>        <span class="hljs-attr">type</span>:<span class="hljs-string">"ExpressionStatement"</span>,</li><li>        <span class="hljs-attr">expression</span>: {</li><li>            <span class="hljs-attr">type</span>: <span class="hljs-string">"UpdateExpression"</span>,</li><li>            <span class="hljs-attr">operator</span>: <span class="hljs-string">"++"</span>,</li><li>            <span class="hljs-attr">argument</span>: {</li><li>                <span class="hljs-attr">type</span>: <span class="hljs-string">"MemberExpression"</span>,</li><li>                <span class="hljs-attr">object</span>: {</li><li>                    <span class="hljs-attr">type</span>: <span class="hljs-string">"ArrayExpression"</span>,</li><li>                    <span class="hljs-attr">elements</span>: [{</li><li>                        <span class="hljs-attr">type</span>: <span class="hljs-string">"ArrayExpression"</span>,</li><li>                        <span class="hljs-attr">elements</span>: []</li><li>                    }]</li><li>                },</li><li>                <span class="hljs-attr">property</span>: {</li><li>                    <span class="hljs-attr">type</span>: <span class="hljs-string">"Literal"</span>,</li><li>                    <span class="hljs-attr">value</span>: <span class="hljs-number">0</span></li><li>                }</li><li>            }</li><li>        }</li><li>    }]</li><li>}</li><li></li><li><span class="hljs-comment">//语句</span></li><li>++[]</li><li><span class="hljs-comment">//语法树</span></li><li>ast = {</li><li>    <span class="hljs-attr">type</span>: <span class="hljs-string">"program"</span>,</li><li>    <span class="hljs-attr">body</span>: [{</li><li>        <span class="hljs-attr">type</span>:<span class="hljs-string">"ExpressionStatement"</span>,</li><li>        <span class="hljs-attr">expression</span>: {</li><li>            <span class="hljs-attr">type</span>: <span class="hljs-string">"UpdateExpression"</span>,</li><li>            <span class="hljs-attr">operator</span>: <span class="hljs-string">"++"</span>,</li><li>            <span class="hljs-attr">argument</span>: {</li><li>                <span class="hljs-attr">type</span>: <span class="hljs-string">"ArrayExpression"</span>,</li><li>                <span class="hljs-attr">elements</span>: []</li><li>            }</li><li>        }</li><li>    }]</li><li>}</li></ul></code></pre><p><span><code>++</code>运算符前置的表达式被称做<code>UpdateExpression</code>，而这两句话的主要区别就在于这之内包含的另外的表达式。在<code>++[[]][0]</code>中的表达式被称做<code>MemberExpression</code>，它的意思是对象成员访问；而在<code>++[]</code>中的则是被称做<code>ArrayExpression</code>，它则是数组字面量。</span></p><p><span>接下来，我们来看看规范之中对这些表达式成分的规定。规范中表达式的种类很多，并且它们还能够相互嵌套，看起来很绕。我把它们汇总了起来，并省略掉部分和这里无关的内容，下面就是<code>UpdateExpression</code>表达式中允许的表达式成分列表：</span></p><blockquote><ol><li><p><span>UpdateExpression</span></p></li><li><p><span>LeftHandSideExpression</span></p></li><li><p><span>UnaryExpression</span></p></li><li><p><span>NewExpression</span></p></li><li><p><span>CallExpression</span></p></li><li><p><span>MemberExpression</span></p></li><li><p><span>PrimaryExpression</span></p></li><li><p><span>SuperProperty</span></p></li><li><p><span>MetaProperty</span></p></li><li><p><span>NewTarget</span></p></li><li><p><span>SuperCall</span></p></li><li><p><span>Arguments</span></p></li><li><p><span>ArgumentList</span></p></li></ol></blockquote><p><span>列表的第一个并不是错误，表达式是允许嵌套自己的。</span></p><p><span>对比上面的语法树可以明显的发现，<code>UpdateExpression</code>表达式并不包含<code>ArrayExpression</code>，所以<code>++[]</code>会抛出的语法错误。另外，<code>MemberExpression</code>是归类在<code>Left-Hand-Side Expressions</code>之中的，所以这里的错误名称是<code>Invalid left-hand side expression</code>。</span></p><h1 id="[ ]运算符"><code>[ ]</code>运算符</h1><p><span>我们明白了<code>++[]</code>出错是因为不符合JavaScript的语法，但这还不足以打消我们的疑问。虽然<code>++[[]][0]</code>是符合语法的，但它在运行过程中仍然会变成<code>++[]</code>，为什么不会报错呢？</span></p><p><span>这个问题其实很简单，因为JavaScript的语义有两种，静态语义和动态语义，编译的时候检查静态语义以及语法结构，运行时则会使用另外一套语义。</span><span>所以，我们要探究为什么<code>++[[]][0]</code>为什么不会抛出错误，就必须要检查它们的动态语义。</span></p><p><span>运算符<code>[ ]</code>的优先级高于<code>++</code>，所以我们首先就来看看<code>[ ]</code>运算符：</span></p><blockquote><p><span>MemberExpression: MemberExpression <strong>[</strong>Expression<strong>]</strong></span></p><ol><li><p><span>Let baseReference be the result of evaluating MemberExpression.</span></p></li><li><p><span>Let baseValue be ? GetValue(baseReference).</span></p></li><li><p><span>Let propertyNameReference be the result of evaluating Expression.</span></p></li><li><p><span>Let propertyNameValue be ? GetValue(propertyNameReference).</span></p></li><li><p><span>Let bv be ? RequireObjectCoercible(baseValue).</span></p></li><li><p><span>Let propertyKey be ? ToPropertyKey(propertyNameValue).</span></p></li><li><p><span>If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.</span></p></li><li><p><span>Return a value of type Reference whose base value component is bv, whose referenced name component is propertyKey, and whose strict reference flag is strict.</span></p></li></ol></blockquote><p><span>前四步很好理解，就是取出<code>[]</code>左边的<code>MemberExpression</code>，评估并对它求值；然后取出<code>[]</code>里面的<code>Expression</code>，同样的评估和求值。这里的求值运算（<code>GetValue()</code>）有两个含义，对表达式求值，以及取出引用类型变量所引用的对象实例。</span><span>第5步中的<code>RequireObjectCoercible</code>实际上是个类型检查，碰到<code>null</code>和<code>undefined</code>的时候会抛出类型错误，其余情况下直接返回。</span><span>第6步则是把第4步求出来的值转换为对象属性，这是解释器内部的变量类型，专门用来访问对象属性的。</span><span>第7步很明显是判断当前是否是严格模式。</span><span>最后就是返回访问的对象属性值。</span></p><p><span>整个过程很简单，也没有什么奇怪的部分。</span><span>接下来我们看看<code>++</code>运算符，它才是我们关心的重点。</span></p><h1 id="++运算符"><code>++</code>运算符</h1><p><span>废话不多说，直接上规范：</span></p><blockquote><p><span>UpdateExpression: ++ UnaryExpression</span></p><ol><li><p><span>Let expr be the result of evaluating UnaryExpression.</span></p></li><li><p><span>Let oldValue be ? ToNumber(? GetValue(expr)).</span></p></li><li><p><span>Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).</span></p></li><li><p><span>Perform ? PutValue(expr, newValue).</span></p></li><li><p><span>Return newValue.</span></p></li></ol></blockquote><p><span>只有短短的5步，前3步没什么好说的，取出表达式评估求值然后<code>+1</code>，这里<code>+1</code>很明显会给<code>[]</code>做隐式类型转换，<code>ToNumber([]) = 0</code>，所以这里的结果就是<code>1</code>。</span><span>然后就是关键的第4步，这里是赋值运算，就是将<code>+1</code>之后的值赋值给表达式的一步。</span><span>按照我们想象的，<code>[]</code>是个常量，这里的赋值必然会失败，但事实告诉我们这里会顺利运行，那么它的过程到底是怎样的呢。</span></p><h2 id="PutValue()"><code>PutValue()</code></h2><p><span>这里使用的是<code>PutValue()</code>运算，我们来看看它的过程：</span></p><blockquote><p><span>PutValue (V, W)</span></p><ol><li><p><span>ReturnIfAbrupt(V).</span></p></li><li><p><span>ReturnIfAbrupt(W).</span></p></li><li><p><span>If Type(V) is not Reference, throw a ReferenceError exception.</span></p></li><li><p><span>Let base be GetBase(V).</span></p></li><li><p><span>If IsUnresolvableReference(V) is true, then</span></p><ol><li><p><span>If IsStrictReference(V) is true, then</span></p><ol><li><p><span>Throw a ReferenceError exception.</span></p></li></ol></li><li><p><span>Let globalObj be GetGlobalObject().</span></p></li><li><p><span>Return ? Set(globalObj, GetReferencedName(V), W, false).</span></p></li></ol></li><li><p><span>Else if IsPropertyReference(V) is true, then</span></p><ol><li><p><span>If HasPrimitiveBase(V) is true, then</span></p><ol><li><p><span>Assert: In this case, base will never be undefined or null.</span></p></li><li><p><span>Set base to ! ToObject(base).</span></p></li></ol></li><li><p><span>Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).</span></p></li><li><p><span>If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.</span></p></li><li><p><span>Return.</span></p></li></ol></li><li><p><span>Else base must be an Environment Record,</span></p><ol><li><p><span>Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).</span></p></li></ol></li></ol></blockquote><p><span>这个运算是JavaScript引擎中通用的表达式赋值的抽象运算，其中有很多格式检查，所以看起来很长。</span></p><p><span>前两步是内部的语句评估判断，可以不管它。到第三步，这里所谓的<code>Reference</code>是指规范内部的引用类型，而不是常规的七大基本类型中的引用类型，这里的这个引用类型包含了<code>undefined</code>、对象，布尔值，字符串、<code>Symbol</code>值、数字以及变量标识符。<code>[]</code>是个对象，所以这里会顺利通过。</span><span>第4步，<code>GetBase()</code>运算就是取出规范引用类型的基值，这里就是<code>[]</code>。</span><span>第5步，假如<code>V</code>是非法引用，并且是在严格模式下，那么抛出引用错误；<code>V</code>是非法引用，但不是严格模式下，那么会隐式创建全局变量，把这个值赋值给这个新创建的全局变量。<code>[]</code>当然不是非法引用，这里跳过。</span><span>第6步，这里的<code>IsPropertyReference(V)</code>方法会判断输入值的类型，当输入值是对象或者类似对象时返回<code>true</code>。<code>[]</code>是对象，满足条件。</span><span>第6.1步，这里的<code>HasPrimitiveBase(V)</code>是当<code>V</code>布尔值、字符串、Symbol以及数字的时候才会返回<code>true</code>，所以这里跳过。</span><span>第6.2步，这里使用对象内部方法<code>[[Set]]</code>将值<code>W</code>作为了对象的属性值赋值到了<code>V</code>内部。这个值的属性名称则是<code>V</code>的引用名称，这里是规范内部的名称，我们在外面是访问不到的，总之这里的赋值操作是成功的，<code>succeeded = true</code>。</span><span>所以最后跳过6.3步，直接返回。</span></p><p><span>最后回到<code>++</code>运算符最后一步，整个表达式返回新的值，运算结束。</span></p><h1 id="总结">总结</h1><p><span>经过上面这么多分析，我觉得可以稍微总结一下了：</span></p><ol><li><p><span><code>++[]</code>的错误是语法错误，在编译阶段就会抛出，而不会等到运行阶段。</span></p></li><li><p><span>动态语义和静态语义的<strong>不同</strong>是造成这个问题的主要原因。</span></p></li></ol><p><span>在最开始我提到了一句：<code>++[]</code>报错符合直觉，而<code>++[[]][0]</code>不报错违反了直觉。</span><span>其实我们再仔细想想就能明白，它们其实都是符合直觉的，不过并不是<strong>我们</strong>的直觉，而是<strong>解释器</strong>的直觉。</span></p><p><span><code>[]</code>是数组字面量，它毫无疑问的是常量，但是<code>[[]][0]</code>呢？我们一眼就看出它也是常量，但是对于解释器却不是如此。我们所谓的<code>一眼</code>其实已经对它进行了运算，求出了这个表达式的结果<code>[]</code>，所以我们下意识的觉得它就是个常量，但是对于解释器却不是如此。在运行前的编译阶段，解释器只会对代码做词法和语法分析，而不会运行代码。</span><span>所以，<code>[[]][0]</code>这个表达式对于解释器来说，其实是个黑箱，解释器并不知道它的结果是常量。因为数组内元素也可以是变量，那么解释器认为这里符合语法也就可以理解了。</span></p><p><span>JavaScript有着相对更灵活的语法，更“动态”的类型，给编程者带来了很多方便的同时，也带来了各种奇奇怪怪的坑。虽然在实际使用中这样的代码几乎不太可能出现，但是研究这类代码的运行机制对于我们理解JavaScript也是有好处的。</span></p></article><footer class="post-footer"><span><a href="/categories/#软件设计">软件设计</a></span><span><a href="/tags/#JavaScript">JavaScript</a><a href="/tags/#规范">规范</a></span></footer><nav><div class="prev"><a href="/archives/2016/10/simple-promise/" title="“简单”的Promise"><p>上一篇：</p><p>“简单”的Promise</p></a></div><div class="next"><a href="/archives/2016/09/scope-closures/" title="作用域和闭包"><p>下一篇：</p><p>作用域和闭包</p></a></div></nav></div><aside id="post-toc"><div><p class="toc-title">文章目录</p><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简述"><span class="toc-number">1.</span><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#句法结构"><span class="toc-number">2.</span><span class="toc-text">句法结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#[ ]运算符"><span class="toc-number">3.</span><span class="toc-text">[ ]运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#++运算符"><span class="toc-number">4.</span><span class="toc-text">++运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PutValue()"><span class="toc-number">4.1.</span><span class="toc-text">PutValue()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span><span class="toc-text">总结</span></a></li></ol></div></aside></article><footer>Powered by&nbsp;<a href="/">Xiao</a> © 2014 - 2016<div id="goto-up"></div></footer><script type="text/javascript" src="/js/jquery-3.1.0.min.js"></script><script type="text/javascript" src="/js/page.js"></script></body></html>